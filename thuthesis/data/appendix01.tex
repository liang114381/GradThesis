\chapter{外文资料的书面翻译}

\title{\large Secure Multiparty Computation Goes Live}
\title{\small Peter Bogetoft, Dan Lund Christense, Ivan Damg\aa rd, Martin Geisler, Thomas Jakobsem,\\Mikkel Kroigaard, Janus Dam Nielsen, Jesper Buus Nielsen, Kurt Nielsen, Jakob Pagter,\\Michael Schwartzbach, Tomas Toft}

{\heiti 摘要：} 2008年1月我们进行了多方安全计算的首次大范围的实际应用，本文就此次应用及其中所采用的密码学方法进行报告。

\section{引言及历史}
在多方计算（MPC）中，我们考虑了一系列参与者 $P_1,\dots,P_n$. 每个人
一开始持有输入 $x_1,\dots,x_n$，我们想在这些输入上安全地计算一个函数 $f$ 满足$f(x_1,\dots,x_n)=（y_1,\dots,y_n）$，使得$P_i$可以得到$y_i$但无法获得其他信息。我们允许参与者表现出一定程度的敌对行为而这个性质依然成立。这个目标可以通过让所有参与者遵从某个协议$\pi$进行交互来实现。直觉上来说，我们希望执行$\pi$等价于有一个被信任方$T$先从$P_i$私下接收$x_i$，然后计算函数$f$，并最后将$y_i$返回给每个$P_i$。有了这样的协议，我们原则上可以解决几乎所有的密码协议问题。MPC的一般理论始于80年代后期[16,3,7]。这个理论后来被发展出有几种实现方式（例如[21,18,8]）。可以在[6]中找到已知理论结果的概述。

尽管MPC在解决许多的问题方面具有明显的潜力，但我们可以看到在过去几乎没有MPC的实际应用。这可能部分是由于以下事实：直接实施原始的通用MPC协议将导致解决方案非常低效。另一个因素则是广大公众长期对该技术潜力的普遍缺乏理解。事实上大量的研究已经用于解决效率问题，包括通用协议[11,17,9]以及诸如投票等特殊类型的计算[4,12]。

另一个不同的研究路线明确地关注一系列经济应用，这对于实际应用特别有帮助。例如，两个本文作者参与的项目就采取了这种方法：SCET（Secure Computing, Economy and Trust）2和SIMAP（Secure Information Management and Processing）。它们在本文中被用于描述MPC的实际应用。在经济领域的机制设计中，一个值得信赖的第三方的概念自70年代以来一直是一个重要的假设[15,19,10]。自从该领域诞生以来，它的发展势头迅猛，变成了一个真正的交叉学科。今天，许多实际的机制设计需要一个值得信赖的第三方是很自然的考虑。而MPC提供了实现这一点的一种可能性。特别地，我们考察过一下这些场景：
\begin{itemize}
	\item 由于各种原因需要进行密封投标的许多类型的拍卖。 其中最著名的可能是密封投标的标准最高出价拍卖。而另一个考虑成交额的常见拍卖类型是许多卖家和买家参与的所谓的双向拍卖。 这种拍卖用于解决寻到商品的公平市场价格和市场需求。
	\item 基准测试。多家公司想要整合它们的业务信息，以便将自己与该地区的最佳做法进行比较。基准测试过程被用于学习，计划或别的目的，而这个过程自然必须在保护公司数据私密性的前提下进行。
\end{itemize}

在考虑这样的应用时，人们发现所需的计算基本上是中等规模（如大约32位）整数上的初等算术。更具体地说，在相当广泛的情况中只会用到加法，乘法和整数比较。加法
和乘法可以通过著名的通用MPC协议相当有效地处理。实际上，因为协议基于$\mathbb{Z}_p$的秘密分享，该协议的做法是选择与输入数字相比足够大的$p$，然后进行模素数$p$的运算。我们可以避免模块化的减少和获得整数加法和乘法。

由于每个数字都是使用线性秘密共享方案来“一件一件”共享的，这种方案有时是高效的。以安全加法为例，每个玩家只需要进行一次本地加法即可。不幸的是，这也意味着比较运算要困难得多。通用的解决方案通过在$\mathbb{Z}_p$上进行算术电路运行来实现比较运算，但由于电路无法直接地访问输入的二进制表达，从而所需的算术电路规模会非常大，以至于其无法成为实际的解决方案。因此我们必须开发用于比较的特殊用途技术。这方面的一个例子是固定轮数的无条件安全的比较协议[13]。

\section{主要贡献}
在本文中，我们报道了使用MPC实施的第一次大规模实际实验 --- 一个安全的拍卖。我们阐述了其应用场景并论证了多方计算是该问题一个很好的解决方案。我们描述并报告了该系统的运作方式。 最后，我们详细阐述了所使用的密码协议并证明了它们的安全性。同时，对于实践中常见的数字规模，我们提出了一个相比[13]更实用的对数循环比较协议。

\section{应用场景}
在本节中，我们将描述我们系统部署的实际情况。 在[1]中已经初步描述了该场景的计划和小规模演示的结果。

在丹麦，有数千农民生产甜菜，并销售给丹麦市场上唯一的甜菜加工商Danisco。农民们会签署一份合同，该合同规定了他们会向Danisco提供一定数量的甜菜，而丹尼斯克会根据某种定价方案向他们支付一定费用。 这些合同可以在农民间交易，但这样的交易历来非常有限，且主要通过双边协商完成。

但近年来，欧盟大幅减少了对甜菜生产的支持。再加上其他因素，这意味着现在迫切需要重新分配合同给农民以使他们得到最佳的回报。人们意识到，这最好是通过全国范围内的交换完成，即双向拍卖。

{\heiti 市场清算价格}：特定商业案例的详细信息可以在[2]中找到。这里，我们简要总结一下重点，稍后将给出所要进行的实际计算的更多细节。我们的目标是找到所谓的市场清算价格（MCP），即每单位待交易的价格。具体来说，每个买方将给出对于每个可能的价格，他愿意用该价格购买多少数量的商品。同样的，卖家将给出他们愿意在每个可能的价格上卖出多少商品.所有的出价都将交给拍卖商。他们会计算出每种价格下的总供求市场。由于我们可以假设随着价格增加供给增加而需求减少，我们可以找到一个价格使得总的供给等于总的需求，拍卖商将把这个价格作为清算价格。最后，所有的参与者将依照这个清算价格进行交易。

{\heiti 使用安全MPC进行投标的保密性}：一个满意的这类拍卖的实现需要考虑到安全问题：投标显然会泄露个人信息，例如农民的经济地位和他的生产力，因此鉴于Danisco在市场上的地位，农民不愿意接受Danisco作为拍卖商。即使Danisco绝不会在正在进行的合同（包括定价方案）再谈判中滥用其所获得的拍卖信息，仅仅对会发生这种情况的担忧可能会影响农民的出价并导致拍卖效果不理想。另一方面，一份合同中的标称数量由Danisco管理（并经常根据欧盟的管理调整）。在某些情况下，合同充当农民对于Danisco债务的担保。因此，独立于Danisco运行拍卖也是不现实的。最后，通过委托法律责任和实际责任给被信任的拍卖人，比如顾问机构，来完成拍卖将会非常昂贵。

最终决定的解决方案是进行电子双重拍卖。这里拍卖人实际上是来自Danisco，DKS和SIMAP项目的代表进行的三方计算。这个三方解决方案被选中部分原因在于它很自然地适合于这个场景，同时也因为它允许使用高效的信息学理论工具比如秘密共享，而不是更昂贵的加密方法，如同态加密。

{\heiti 动机}：是什么动机使得DKS和Danisco尝试使用这样一个新的、未试验的技术呢？一个重要因素是全国性的生产权利交换的明显需求在一前是不存在的，所以无论安全与否，低成本的电子化解决方案是一个巨大优势。但是，我们确实相信安全性也很重要。一个与拍卖有关的在线调查显示，农民确实会关心他们出价的保密性（见图1和图2中的表格）。如果Danisco和DKS试图用传统的方法进行拍卖，一个或多个人必然会得到这些出价，或以明文形式控制出价的系统。 结果是我们必须商定一些安全性政策，比如回答诸如以下问题：谁应该有权访问数据？什么时候有这个权限？如果数据泄漏，谁负责？怎么负责？

由于参与者们利益冲突，这将导致冗长的讨论，甚至可能让整个项目停摆。在对Danisco和DKS（甜菜种植者协会）有关决策者的采访中，
这些保密问题都得到了认可。如同前面提到的，雇用咨询机构作为协调人会昂贵的多，并且各方必须对协调人提出的安全政策是否令人满意达成共识。有趣的是，我们没有必要进行这种谈判，因为多方计算确保没有人会在任何时候获得出价信息。

值得注意的是，半诚实的模型中，安全多方计算已经实现了人们可以“选择不知道”。因此我们判断，一个半诚实安全的方案对于实现拍卖人的已经足够了。但请注意，来自投标者们的主动攻击仍然是可能的。虽然我们认为在我们的具体情况中，这不是一个重大风险，接下面我们仍会给出防范恶意投标者的协议。

有人可能会问，我们真的需要多方计算的全部威力吗？我们的方案确保没有任何一个单一玩家可以获得任何敏感信息，而且看上去在类似的信任模型中我们可以使用投票协议中的常用技巧来更有效率地解决这个问题：一个当事人$P_1$收到来自投标人的加密过的投标书。投标书是用另一方$P_2$的公钥加密的。然后$P_1$发送随机置换后的加密信息给$P_2$. $P_2$解密收到的消息并计算市场清算价格。因为$P_2$不知道谁放置了哪些出价，这种方案实现了一些安全性，但我们必须记住出价包含的信息比结果（市场清算价格）所传递的信息多得多。例如，可以查看人们愿意以清算价格以外的其他价格购买或出售的数量。原则上，这种类型的信息对于像Danisco这样的单一经营者来说是非常有价值的，以便发挥其市场能量。比如用于确定扩展或减少总的处理量的价格。这样的情况有多大程度会在实际生活中发生是很难回答的。我们的结论是使用全面的多方计算是一个更好的解决方案，因为它可以让我们根本不去考虑这个问题。

\section{加密协议}
抽象掉一些不太相关的细节后，我们的场景如下：一些输入客户端$I_1,\dots,I_m$为多方计算提供输入，这将由服务器$P_1,\dots,P_n$执行。在我们感兴趣的案例类型中，$m$非常大而$n$被认为是小的常数。 在我们的具体案例中，$n=3$而$m$约为1200。

来自客户端$I_i$的输入是非负整数的有序列表$\{x_{ij}|j=1,\dots,P\}$,其中下标$j$表示$x_{ij}$对应$P$个可能的单位价格中的一个，这$P$个价格按照增序排列。这样的名单被称为一个出价。 一个出价被称为出售出价，如果对应的列表是非减的，或者被称为买入出价如果对应的列表是非增的。对于一个买入出价，$x_{ij}$是投标人希望以第$j$个单位价格购买的数量。类似地我们定义$y_{ij}$为投标人愿意以价格$P_j$出售的数量。 由于实际条件的限制，这些输入必须能够以非交互方式（安全地）传送到服务器。

安全计算包括计算每个价格的总的需求和供给，即
$$
d_j=\sum_{i}x_{ij},\ s_j=\sum_i y_{ij},\ j=1,\dots,P，
$$
并最终找到合于$d_{j_0}-s_{j_0}=0$的$j_0$, 或者只是让这个差尽可能接近0（但可能不等于0）。由于可能的（$P$个）价格是离散的，我们期望找到差精确地等于0的$j_0$。这也意味着必须要有一致认可的规则用来确定是接受供给略大于需求还是需求略大于供给。在我们的这个具体案例中我们制定了这样的规则，但其细节超出了这篇文章的范围。

任何情况下，随着价格的增加，供给增加而需求减少，因此我们能够通过二分查找很快找到所需的$j_0$. 注意到公开进行这样的比对是安全的：我们想要得到的$j_0$最终是公开的。因此对任意$j$,$d_j$和$s_j$之间的比较结果都可以从公开的$j_0$得到。最后除了$j_0$会被公开，所有对应于价格$j_0$的买入卖出量$x_{ij_0},y_{ij_0}$都会被公开。

因此我们只需设计一个协议实现理想功能$\mathcal{F}$：
\begin{enumerate}
	\item
	来自客户端$I_j$的输入$\textup{Input}(x_1,\dots,x_P)$：$x_1,\dots,x_P$是一个整数列其中每个数之多$l$位（$l$是常数）长。此外这个数列要么是不减的，要么是不增的。$\mathcal{F}$将这些数字存储到唯一命名的寄存器中，并通知所有的参与者和对手一个输入数列已经从$I_j$处收到以及它们对应的寄存器名。
	\item
	输入 $C=A+B$：$A,B,C$ 是$\mathcal{F}$的寄存器名。$\mathcal{F}$计算$A$中数字和$B$中数字的和并将结果存储在$C$中。
	\item 
	输入 $C=A\times B$：$A,B,C$ 是$\mathcal{F}$的寄存器名。$\mathcal{F}$计算数字$A$中数字和$B$中数字的积并将结果存储在$C$中。
	\item
	输入 $\textup{ConstantMult}(a,B)$：$a\in \mathbb{Z}_p$，$B$是一个寄存器。$\mathcal{F}$计算$a$和$B$中数字的积并将结果存储在$B$中。
	\item
	输入 $\textup{Compare}(A,B)$, $\mathcal{F}$ 发送1给所有服务器如果$A$中的数字大于$B$中的数字，否则发送0给所有服务器。
	\item 
	输入 $\textup{Open}(A)$, $\mathcal{F}$ 发送寄存器$A$中所存数字到所有服务器。
	\item 
	输入 $\textup{RandomBit}(A)$, $\mathcal{F}$ 从$0/1$中随机选择一个数然后存储在寄存器$A$中。
\end{enumerate}

我们将假设一个静态且被动的对手，其可以破坏任意数量的输入客户端以及任意少数的服务器。我们接下来会说明以效率为代价，我们可以允许主动的，对客户端的攻击。然而在我们这个具体的案例中，我们认为这种来自客户端的主动攻击的风险非常小，以至于没有必要去付出效率上的代价。

我们的实现基于标准的Shamir秘密共享，包含$n$台服务器。我们用到了一个素数域$\mathbb{Z}_p$其中$p$被特别选取以满足其（二进制）长度恰好为$l+\kappa$。$\kappa$是一个用于控制比较协议的统计性质安全的参数。在我们这个具体案例中，$l=32$且$p$是一个65位素数。

令$t=\lfloor(n-1)/2\rfloor$，当需要秘密共享一个数字时，随机的选取一个至多$t$次的多项式$f$合于$f(0)=x$.这么一来$x$的$n$个共享将是$f(1),\dots,f（n)$。我们这里用$[x]$表示$x$的$n$个共享的集合。

设$\mathcal{F}'$是另一个功能，其除了不支持比较命令外，完全和$\mathcal{F}$一样。接下来我们会阐述如何实现$\mathcal{F}'$，以及如果基于$\mathcal{F}'$实现$\mathcal{F}$。

{\heiti 配置公钥：} 我们的实现假设公钥/私钥已经在计算开始前在服务器上被配置完成，且公钥对所有客户端公开。更精确地说，对于每个极大的不合格集合（即$|A|=t$），我们需要所有不在$A$中的服务器都持有私钥$sk_A$，且公钥$pk_A$对所有参与者（包括客户端和服务器）公开。

{\heiti 非交互式输入:} 第一个问题是现在如何去实现一个客户端输入数字$x_1,\dots,x_P$的命令。最直接的做法是秘密共享每个$x_i$然后用对应服务器的公钥进行加密。由于存在多个服务器，这样做会导致客户端需要发出多倍的信息。

因此我们给出一种非交互式VSSS技术[14]。简洁起见，在这里我们基于我们的具体案例（$n=3$）来描述这种技术。首先我们有3个密钥对$(pk_i,sk_i),i=1,2,3$，服务器$i$持有两个私钥$sk_j,j\neq i$。现在令$f_i(x),i=1,2,3$表示3个次数不超过1的多项式，并满足$f_i(0)=1,f_i(i)=0$。现在可以按如下方式以加密形式传递一系列数字$x_1,\dots,x_P\in\mathbb{P}$给服务器组：
\begin{enumerate}
	\item 选择伪随机函数（PRF）$F$的三个密钥$K_1,K_2,K_3$。其以指数$j$为输入并输出一个$\mathbb{Z}_p$中的元素。
	\item 输出加密$E_{pk_i}(K_i),i=1,2,3$.
	\item 对于$j=1,\dots,P$，计算并输出：
		$$y_j=F_{K_1}(j)+F_{K_2}(j)+x_j\ \mod\ p$$
\end{enumerate}
每个服务器$P_a$现在可以处理这样一个加密并计算每个数字的Shamir共享：
\begin{enumerate}
	\item 从$E_{pk_i}(K_i)$中解密两个明文，这里$i\neq a$。
	\item 计算$x_j$的共享$share_{a,j}$：
	$$share_{a,j}=y_j-F_{K_1}(j)f_1(a)-F_{K_2}(j)f_2(a)-F_{K_3}(j)f_3(a)$$
	注意这里$f_a(a)=0$，所以我们可以不用知道$K_a$是多少。
\end{enumerate}

如果我们定义多项式$g_j$为$g_j=y_j-F_{K_1}(j)f_1-F_{K_2}(j)f_2-F_{K_3}(j)f_3$，那么
$$\deg(g)\leq 1,g_j(0)=x_j,g_j(a)=share_{a,j}.$$
因此我们已经得到一个有效的共享集。

我们可以使用阈值为$t$的Shamir共享，将这种做法推广到任意数量的服务器：首先进行一般化的密钥配置，即对每个大小为$t$的服务器，配置一个密钥对$(pk_A,sk_A)$，将$sk_A$发送给所有不在$A$中的服务器。然后找到$t$次的多项式$f_A$满足$f_A(0)=1$且$f_A(i)=0$对于所有$i\in A$。当然这种做法无法被用于较大的$n$,但在我们的应用中不需要考虑这一点。

这种方法有如下几个优点：
\begin{enumerate}
	\item 除了取决于服务器数量的额外的开销，被加密的数列和原数列有相同的规模。
	\item 假设公钥体系的解密算法是确定性的，那么解密过程总会产生某个数列的一致的共享。
	\item 如果某个服务器丢失了它的私钥，那么这个私钥可以从其它服务器处重新获得。
	\item 我们只需要从客户端到向服务器的通讯。这在实际使用中会非常方便，尤其是当我们只能控制相对较少数量的服务器的配置而不是相对较多的客户端配置时。比如说防火墙可能会使得服务器向客户端发送数据更加困难。
\end{enumerate}

{\heiti 加法和乘法：}在输入阶段后，所有的数字通过次数不超过$t$的多项式进行共享。我们可以通过标准协议来实现加法和乘法，并保持不变性质：$\mathbb{F}$中存储在寄存器中的数字和真实协议中秘密共享的数字保持一致。作用在输入$[a],[b]$上的加法运算可以通过令所有服务器本地执行加法运算来完成。显然$[a]+[b]=[a+b]$，因为秘密共享的算法时线性的。类似地，乘以一个常数可以通过所有服务器将它持有的共享呈上这个公共常数来完成。对于一般的乘法，服务器$P_i$先计算输入$a,b$的共享乘积$d_i=a_ib_i$，$P_i$向所有服务器分发共享$d_i$并得到$[d_i]$。最终，所有服务器计算$[ab]=\sum_i \lambda_i[d_i]$，其中$\lambda_i$是拉格朗日插值的系数。对任意不超过$n-1$的多项式$g$，其满足$g(0)=\sum_i \lambda_ig(i)$。由于$2t\leq n-1$，所以该插值可以用于重建$[ab]$。

{\heiti 随机比特：}我们用一个技巧[13]来实现函数RandomBit。所有的服务器秘密分别共享一个随机量，然后在本地对它们求和得到一个未知的随机数$[u]$。然后我们计算$[v]=[u^2\mod p]$并公开$v$。如果$v=0$那么重新再计算一次。否则继续公开地计算$v$的平方根$w$，并约定选择较小的那一个。接下来计算$w^{-1}[u]\mod p$，这个数会以$1/2$的概率为1以及$1/2$的概率为-1。因此$[(w^{-1}u+1)2^{-1}\mod p]$将给出我们需要的随机比特。
\newline

\noindent\textbf{引理1.} 如果所使用加密是语义安全的且$PRF$也是安全的，那么上述的协议在如下意义下安全地实现了$\mathcal{F}'$：攻击的对手是静态的、被动的，其可以破坏任意数量的客户端以及至多$t$台服务器。

证明略。
\newline

{\heiti 无需信任客户端的输入：} 上述方法无论客户端做什么都能产生一致的共享数字，但原则上客户端可能发送很大的数字，这可能会导致计算失败。我们可以防止这种情况发生，即我们将伪随机值$F_{K_i}（j）$的大小设为$l+\kappa$比特，选择$p$的长度为$2(l+\kappa+\log T)$比特，其中$T$是最大无危胁集$A$的数目，其余则按照上述相同协议发送输入。

客户发送的消息中的每个$y_j$应该是$T$个伪随机值的总和以及要共享的实际秘密。通过选择$p$的大小，如果$y_j$被正确地构造，则这个总和将不涉及任何约简模。因此，我们可以要求每个yj最多只有一个$\kappa+l+\log T$位数，否则拒绝输入。即使$y_j$没有正确构造，这也保证了我们最终得到的份额将是形式$y_j-\sum_{A}F_{K_A}(j)$，因此必须在数值上比$p$小，实际上它必须在区间$[-2^{\kappa+l+\log T},2^{\kappa+l+log T}]$。我们可以很容易地看到，一旦我们知道我们使用的数字有这样的约束，我们可以使用稍后显示的比较协议，实际上唯一的假设是要比较的数字足够小于$p$。因此，服务器可以检查输入数字是否为正数，并根据需要增加或减少。
最后，所使用的公钥加密必须选择安全的密文以对付恶意输入客户端，并且每个加密的明文都必须包含预期接收者的标识。
按照此处所述更改协议会使我们增加$p$的大小，这意味着普遍损失效率，增加数据大小以及检查出价形式的额外工作。另一方面，为了真正作弊，投标人必须编写他自己的客户端程序，并说服服务器端正常客户端仍在使用。就我们的具体情况而言，我们估计出价人以这种方式作弊的风险太小，不足以激发保护它的额外成本。
顺便说一下，我们注意到，可以证明，发送不增加或减少的出价不会增加竞标者的优势，因此无论如何这都是一个小问题。

\subsection{加入安全比较功能}
接下来需要给出如何安全地比较数字。我们将基于对$\mathcal{F}'$的访问来完成这件事。这样结合上一节的结果以及UC合成定理我们就得到了想要的$\mathbb{F}$的实现。注意我们将要比较的数字被假设为具有至多$l$位，而用于秘密共享的素数为$l+\kappa$位长。在如下的协议描述中，我们将对象的算术写作$[d]$。在这个协议中，我们假设可以访问$\mathbb{F}'$，这被理解位一个被$\mathbb{F}'$持有的存有$d$寄存器。在实际的视线中，$[d]$将会是一个$d$的秘密共享。

我们定义一个作用在比特对上的运算$\diamond$为
$$
\begin{pmatrix}
x\\X
\end{pmatrix}
\diamond
\begin{pmatrix}
y\\Y
\end{pmatrix}
=
\begin{pmatrix}
x\wedge y\\
x\wedge(X\oplus Y)\oplus X
\end{pmatrix},
$$
其中$\wedge$表示布尔取和运算符。注意如果我们持有$[a],[b]$，其中$a,b\in \{0,1\}$，那么$[a\oplus b]$可以通过在$\mathbb{F}'$上计算$[a]+[b]-2[ab]$来完成。所以我们可以假设二元取值上的$\oplus$是可用的，从而$\diamond$运算也是可以实现的。容易验证$\diamond$符合结合律。
\newline
\newline
\framebox{
	\begin{minipage}{\textwidth}
	{\heiti 比较协议：}\\
	输入：$[d],[s]$\\
	输出：如果$d\geq s$输出1，否则输出0
	\begin{enumerate}
		\item 对于$i=0,\dots,l+\kappa+1$，调用RandomBit生成$[r_i]$，其中$r_i\in\{0,1\}$是二元随机数。计算$[r]=\sum_i2^i[r_i]$。
		\item 
		计算$[a]=2^{l+\kappa+1}-[r]+2^l+[d]-[s]$。公开$a$，然后计算$a$的各位$a_i$。
		\item 
		计算$a+r=2^{l+\kappa+1}+2^l+d-s$的第$l$位。注意我们现在得到了$a$和$[r_i]$。计算
		$$
		\begin{pmatrix}
		[z]\\ [Z]
		\end{pmatrix}
		=
		\begin{pmatrix}
		[a_{l-1}\oplus r_{l-1}]\\
		[a_{l-1}]
		\end{pmatrix}
		\diamond \dots \diamond
		\begin{pmatrix}
		[a_0\oplus r_0]\\
		[a_0]
		\end{pmatrix}
		\diamond
		\begin{pmatrix}
		0\\0
		\end{pmatrix}。
		$$
		得到的$Z$恰好是计算加法$a+r$时在第$l$位的进位。
		\item 计算$[res]=a_l\oplus [r_l]\oplus [Z]$。公开并输出结果$res$。
	\end{enumerate}
	\end{minipage}
}

设计这个协议的一些直觉：比较数值$d$和$s$时，很容易看出比较结果是从$2^l+d-s$的第$l$位开始（从0开始计数）。该位分两步提取：首先将问题转换涉及数字的二进制表示可用的问题。而这个转换后的问题可以很容易地解决。
\newline

\noindent\textbf{引理2：}假设我们可以访问功能$\mathcal{F}'$，那么如上的比较协议在$O(\log l)$轮内实现了统计安全的比较运算。

证明略
\newline

\noindent\textbf{定理1：}假设如上协议所使用的加密算法是词义安全的且所使用的PRF是安全的，那么用来实现$\mathcal{F}'$的协议结合用来实现$\mathcal{F}$的比较协议可以抵抗包含任意多客户端和至多$t$台服务器的静态被动攻击。
\newline

\textbf{一个提高效率的技巧：}我们可以更高效地计算二进制数值的比较操作。具体做法是，向$\mathcal{F}'$添加一个命令，在给定包含二进制值的寄存器$[r_i]$时，生成一个包含相同二进制值的新寄存器，但现在将其解释为一个在$GF(2^8)$中的元素，表示为$[r_i]_{256}$。$\oplus$操作现在只是$GF(2^8)$中的加法。这背后的想法是我们将实现$[ri]_{256}$作为在域$GF(2^8)$是共享，以确保安全$\oplus$只是一个本地加法，所以比以前快得多。这将$\diamond$操作减少为单轮，意味着重复应用将只需要$\log(32)=5$轮，远少于原来的10轮。

现在只剩下如何进行转换的问题。我们通过让每个服务器产生$[s_j],[b_j]_{256}$来做到这一点。现在（统计）安全地公开$r_i+\sum_j s_j$。这个数字中最低位等于$r_i\oplus b_1\oplus\dots\oplus b_n$。把它加到$[b_1\oplus\dots\oplus b_n]_{256}$得到$[ri]_{256}$。

我们将其安全性的正式证明留给读者。

\section{结论}
我们与拍卖系统有多成功，这项技术是否在实践中具有更大的潜力？

除了系统能够正常工作并产生正确结果之外，值得注意的是，在线调查中约80％的受访者表示，对他们来说出价的保密对于他们很重要，因此他们对系统所带来的保密性感到很满意。当然，我们不应该将其解释为对他们对我们所选择的技术解决方案的支持，大多数农民并不知道多方计算是什么。虽然如此，有趣的是，保密性仍然被认为是重要的。虽然有时有人声称是普通人不会关心安全问题，但我们相信他们有时候会很在意，特别是涉及到钱的时候。当其他参与者涉及到明显与之相关的冲突利益关系时，则更是如此。例如，鉴于甜菜市场的历史，毫无疑问，对农民来说“保密”包括了对丹尼斯克的保密性。 Danisco和DKS很满意该系统，在撰写本文时，拍卖已经第二次成功运行。

在实验进行中，我们认可了多方合作的能力。把所有不打算公开的东西保密，在实践中非常有用。如之前讨论的，它避免了去讨论哪些部分的数据是敏感的以及处理这些数据应该有哪些共识的安全政策的麻烦。

有人会认为使用安全硬件可以实现同样的效果：只需保密地发送所有输入数据到设备然后进行内部计算，并输出结果。表面上，这似乎是一个非常简单的解决方案，也可以保护所有私人数据。然而，仔细观察就会发现，不难看出即使人们相信物理保护不能被破坏，硬件解决方案所能够实现完全不同于多方计算。：请注意，此时我们系统的一些组成部分（硬件盒）仍然可以明文访问所有私人数据。如果我们是在谈论一个抽象的理想功能，这不会是一个问题。但现实中一个的硬件盒就是一个系统组件，像别的组件那样，它必须安全地被安装，管理，更新，备份等。这必须在一个各方达成一致的安全政策下进行，并且各方必须相信管理员严格按照政策操作。如果参与者具有冲突的利益关系，达成协议可能会耗时，高成本，甚至是不可能的。我们认为安全硬件更加自然的使用方式是用来提高其本身的安全性，即他的系统所泄漏的信息只有协议中所需的消息。

MPC的另一个标准的替代品是雇用一个值得信赖的中间方，如顾问机构来进行计算。我们之前说过，在我们的情况下，参与者不愿意这样做因为它的成本昂贵得多。当然，人们可以声称这只是因为另一种方法（即我们的方法）是让一个研究团队出于实验目的去免费完成整个项目，而这并没有表明MPC在商业上可行。虽然这个实验没有产生一个商业计划，我们希望指出，一个基于MPC的解决方案只需要开发一次，而这个成本可以在许多应用程序中摊销。在某些情况下，甚至可能不需要进行适配。例如，在甜菜拍卖的例子中，相同的拍卖很可能将在一段时期内每年运行一次。

总之，我们预计未来多方计算将在许多实际情况中变得有用。