\chapter{引言}
\label{cha:intro}

随着生物技术及药品研发的发展，制药企业的药品实验的成本和规模也日渐增加。如果各个企业仅是独立地进行药物研发，无疑会产生大量的资源浪费。例如当某个企业已经实验过某种药物的特性，但尚未公开，则另外一个企业对于同种或类似药物但实验则意味着资源的浪费。对此，企业之间对正在研发药物的信息共享可以很好的避免这一类问题。不幸的是，由于专利和对盗用的担忧，绝大部分企业不愿意如实地向竞争对手公开研发中的药物信息。

一种可能的解决方案是通过可信任的第三方来实现信息共享。但这至少可能具有以下问题：
\begin{itemize}
	\item 需要找到一个各方都能够信任的第三方，但这在很多情况下并不现实或者完美。例如机构很有可能对于参与共享的制药企业有事实上的利益偏好（如来自不同的国家或是地区的企业），从而有泄漏信息的动机以及由此带来的风险。
	\item 当整个系统足够庞大时，第三方本身的安全性仍然需要更多的措施来保障。一个集中各方数据的第三方很自然的会是攻击者的首要目标。第三方数据库的泄漏将将远大于两个药企之间直接共享数据带来的损失。
\end{itemize}

对此，我们的想法是，一个去中心化，或是部分去中心化的解决方案可以很大程度上地解决如上这些问题。具体地说，我们考虑采用MPC（Secure Multi-party Computation，多方安全计算）来实现制药企业之间所需的信息共享。由于采用MPC协议可能需要交换的信息量过大，这时我们考虑先进行一次 tf-idf 采样，然后用SVD算法将数据点（本文中通常是药物分子的指纹）投影到低维空间\cite{Wan086033}以降低需要交互数据量。下面我们将对所涉及的数个基本概念进行简单介绍。

\section{分子的相似度及分子指纹的基本概念\cite{CERETOMASSAGUE201558}}

不同分子之间的相似度本身是一个相对主观的概念。分子结构的复杂性也导致了一般意义上这个问题的困难。对此，通常的做法是对原始的分子结构进行一定程度的抽象和简化。其中，最常见的方式是将分子结构转化成一个比特串，即所谓的分子指纹（Molecular Fingerprint）。

假设我们得到了两个分子的指纹，分别是比特串$A[1\dots l]$和$B[1\dots l]$。这里为简单其见，我们假设这个指纹具有定长$l$。这样一来，我们可以在$A,B$间定义一些常见的分子相似度如下：
\begin{table}[H]
	\centering
	\caption{一些常见的相似度定义\cite{CERETOMASSAGUE201558}}
	\begin{tabular}{l l l}
		\hline
		相似度名称 & 表达式 & 取值范围\\
		\hline
		Tanimoto系数 & $\frac{c}{a+b-c}$ & $[0,1]$\\
		欧氏距离 & $\sqrt{a+b-2c}$ & $[0,\sqrt{l}]$\\
		汉明距离 & $a+b-2c$ & $[0,l]$\\
		Dice系数 & $\frac{2c}{a+b}$ & $[0,1]$\\
		余弦相似度 & $\frac{c}{\sqrt{ab}}$ & $[0,1]$\\
		\hline
	\end{tabular}
\end{table}
其中
\begin{align*}
a&=|\{i:A[i]=1\wedge B[i]=0\}|\\
b&=|\{i:A[i]=0\wedge B[i]=1\}|\\
c&=|\{i:A[i]=1\wedge B[i]=1\}|
\end{align*}

下面我们考虑如何去计算分子指纹的问题\cite{CERETOMASSAGUE201558}。大多数分子指纹只用到了二维的分子图，而少部分可能用到分子的三维信息，后者在药效团指纹中尤其常见。主要的指纹采集方法包括基于键值的子结构指纹，拓扑或基于路径的指纹，或者是环形指纹。

\section{MPC的基本概念\cite{intro_to_mpc}}
MPC(Secure Multi-party Computation，多方安全计算)被用于包含$n$个参与者的计算问题。我们希望在不泄漏中间信息的前提下得到想要多方计算的函数。更具体地说，假设我们有$n$个输入$x_1,\dots,x_n$，其中第$i$个参与者知道$x_i$但不知道别的输入，我们希望计算多元函数$f$合于
$$
f(x_1,\dots,x_n)=(y_1,\dots,y_n).
$$
并满足第$i$个参与者只能得到$y_i$但得不到其它任何信息。

我们已知某个著名的通用协议来实现这件事。为此我们先引入秘密共享（secret sharing）的概念。首先定义$t=\lfloor(n-1)/2\rfloor$。

假设参与者$i$持有数字$x$（事实上这里的$x\in\mathbb{Z}_p$而不是任意整数），那么参与者$i$可以（均匀）随机地选取一个$\mathbb{Z}_p$上的多项式$g$合于$\deg(g)\leq t$且$g(0)=x$。然后，参与者$i$将$g(j)$发送给参与者$j,\ j=1,\dots,n$。这样一个整个操作称为参与者$i$进行了数字$x$的秘密共享。

注意到由拉格朗日插值法，只要有超过$t$名参与者选择共享他们所持有的共享（如$g(1),\dots,g(t+1)$），那么我们可以重建出$g$进而恢复出所需的$x=g(0)$。另一方面，如果我们只已知$g$在$t$个点上的取值，那么$t$次多项式$g$在所得的条件概率空间中依然满足$g(0)$是$\mathbb{Z}_p$上的均匀分布，即没有任何信息能够从中恢复。因此这保证了联合的攻击者不超过$t$个时$x$的安全性。我们记$[x]$为$x$的共享的集合。

以秘密共享机制为基础，我们可以实现（秘密的）数字上的算术运算。由于秘密共享机制是线性的，加法可以直接通过所有持有共享的参与者在本地对他们所持有的共享来完成。例如$[a]+[b]$即可得到$a+b$在所有参与者上的秘密共享。

\section{tf-idf统计量的基本概念}

在信息检索领域，tf-idf（term frequency-inverse document frequency）是一种统计方法以评估一个单词对于一个语料库中的某个文件的重要性。直觉上来说，显然一个单词对某个文件的重要性与在该文件中出现的次数成正比，但同时随着它在语料库中出现总频率的增加而下降。因此我们将tf-idf统计量定义为tf乘以idf。tf-idf统计量常被用于搜索领域以确定关键词与对应文档（页面）的关联度。tf（词频率）和idf（文档频率倒数）的几种常见的定义如下

\begin{table}[H]
	\centering
	\begin{subtable}{0.45\textwidth}
		\centering
		\caption{几种tf的常见定义}
		\begin{tabular}{ll}
		二元定义 & 0,1\\
		原始计数 & $f_{t,d}$\\
		词频率 & $f_{t,d}/\sum_{t'\in d}f_{t',d}$\\
		对数正规化 & $\log(1+f_{t,d})$
		\end{tabular}
	\end{subtable}
	\begin{subtable}{0.45\textwidth}
		\centering
		\caption{几种idf的常见定义}
		\begin{tabular}{ll}
		平凡定义 & 1\\
		文档频率倒数 & $\log\frac{N}{n_t}=-\log\frac{n_t}{N}$\\
		平滑后的文档频率倒数 & $\log\left(1+\frac{N}{n_t}\right)$
		\end{tabular}
	\end{subtable}
	\caption{tf及idf的常见定义}
\end{table}
其中$f_{t,d}$表示单词$t$在文档$d$中出现的频率，$n_t$表示有单词$t$出现的文档的数量，$N$是总的文档数量。

\section{SVD算法的基本概念}

SVD(Singular Value Decomposition，奇异值分解)算法被用于将一个$m\times n$的矩阵$M$分解为
$$
M=U\Sigma V^T，
$$
其中$U$和$V$分别是$m\times m$和$n\times n$的酉矩阵。而$\Sigma=\textup{diag}(\sigma_1,\dots,\sigma_r,0,\dots,0)$是一个前$r$项非零的对角线矩阵，满足$\sigma_1>\dots>\sigma_r>0$，这里$r$是矩阵$M$的秩。标准的SVD算法时间复杂度为$O(\min\{mn^2,m^2n\})$。

SVD算法可以自然地用于将高维空间的点集投影到低维空间中去。特别地，我们假设$M$的每一列代表一个$\mathbb{R}^m$空间中的一个点，于是$M$表示一个包含$n$个点的$\mathbb{R}^m$中的点集。现在我们希望找到一个矩阵$H\in\mathbb{R}^{d\times n}$用来表示这$n$个点被投影到$\mathbb{R}^{d}$中的结果。我们希望找到一个$\mathbb{R}^m$中的$d$维超平面，让原始点到这个超平面上的投影点距离的平方和最小。可以证明\cite{Stewart92onthe}，
$$
M^*=U_d\Sigma_dV_d^T
$$
即是原始点在该超平面（在$\mathbb{R}^m$中）的投影坐标，其中$U_d$表示$U$的前$d$列，$V_d$表示$V$的前$d$列，$\Sigma_d=\textup{diag}(\sigma_1,\dots,\sigma_d)$。对这$n$个点进行$\mathbb{R}^n$上的旋转变换$U^T$得到
$$
H^*=U^TM^*=\begin{pmatrix}
I_r\\ O_{m-r}
\end{pmatrix}
\Sigma_d V_d^T.
$$
容易看到
\begin{equation}
H=\Sigma_d V_d^T
\end{equation}
即是我们需要的在超平面上的投影的坐标。

\section{本文的主要贡献}